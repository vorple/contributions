! vim: syntax=inform

! achievements.h
! achievement tracking system for Inform 6
! Vince Laviano (vince.laviano@gmail.com)
! Release 0.5 (16 Mar 2016)
!
! The source code in this file is copyright 2016 by Vince Laviano. You may copy
! and distribute it freely, by any means and under any conditions, as long as
! the code and documentation is not changed. You may also incorporate this code
! into your own program and distribute that, or modify this code and use and
! distribute the modified version, as long as you retain a notice in your
! program or documentation which mentions my name and the email address shown
! above.

Include "flags2.h";  ! adapted from Adam Cadre's flags.h
Include "infglk.h";  ! generated by Andrew Plotkin's dispatch_dump.py

! don't produce warnings if users of this extension don't declare objects of
! all of the classes that we provide.
System_file;

! Core design principle: we value simplicity in client games over simplicity in
! this extension; we're willing to make this file gross so that your game
! doesn't have to be.

! ************************************************************************
! IMPORTANT NOTE:
! Games using this extension must call AchievementsInit() in Initialise().
! Specify the name of the file storing persistent achievements as the
! first argument of this call.
! ************************************************************************
!
! Achievements should be defined as follows:
!
! Achievement Foo "Foo"
!   with description "Bozzle the bazzle";
!
! CountingAchievement Bar "Bar"
!   with target_count 10,
!        description "Bozzle the bazzle 10 times";
!
! MultiAchievement Baz "Baz"
!   with num_tasks 6,
!        description "Do 6 different things";
!
! Achievements can be hidden (not listed by the achievements command until
! earned) by defining the achievement object with the concealed attribute:
!
! Achievement SupahSecret "Supah Secret"
!   with description "Do a secret thing",
!   has concealed;
!
! All kinds of achievements can be hidden.
!
! MetaAchievement DoThemAll "Do Them All"
!    with description "earn all achievements",
!         depends_on Foo Bar Baz SupahSecret;
!
! Meta achievements can depend on other meta achievements.
!
! Achievements are awarded by calling award(). This will display a note to the
! player, unless achievements_notify is 0. Checking if an achievement has been
! awarded can be done with the test "if XX in EarnedAchievements".
!
! Achievements can be failed by calling fail(). A failed achievement will cause
! any meta achievements that depend on it also to be failed. It is allowable
! for a game to call award() for a failed achievement and fail() for an earned
! achievement, both of which will do nothing. Checking if an achievement has
! been awarded can be done with the test "if XX in FailedAchievements".
!
! This allows games to implement achievements of the form "do X without doing
! Y" with minimal bookkeeping. Such a game can call fail() when the player does
! Y and award() when the player does X and obtain correct behavior without
! maintaining a record of whether the player has ever done Y.
!
! Failed achievements continue to track progress, even though they will never
! be earned, allowing games to call routines such as is_task_completed() with
! correct results.
!
! Persistent achievements (see below) can also be failed, but we don't
! recommend this from a design standpoint, as an achievement that can never
! again be attempted is demotivating and is likely to lead to players editing
! or deleting the achievements file in order to obtain another chance at it.
!
! Achievements can be made persistent by defining the achievement object with
! the persistent attribute:
!
! Achievement LongLasting "Long Lasting"
!   with description "Do something",
!   has persistent;
!
! Persistent achievements, once earned, persist across restarts, restores, and
! undos. To implement this, achievement data is stored in an auxiliary file in
! a platform dependent way. All kinds of achievements can be persistent.
!
! More complex achievements that don't fall into these classes can be
! implemented using the base Achievement class (or any of its subclasses):
!
! Achievement Fancy "Fancy"
!   with description "do something based on arbitary state",
!        ! add additional properties here as needed
!        evaluate [;
!            ! check arbitary conditions and call self.award() if complete
!        ],
!        progress [;
!            ! print out in-progress state if relevant
!        ],
!        init [;
!            ! perform any necessary initialization
!        ];
!
! Games can arrange for a routine to be called after the user issues the
! "achievements" meta command by passing a reference to such a routine into
! AchievementsInit() as its second arg. This allows a game to implement
! achievements based on the use of the achievements command itself.
! XXX is this worth the complexity?
!

#ifdef TARGET_GLULX;
Constant Ach_Char_Newline = $0a; ! Latin-1
#ifnot; ! TARGET_ZCODE
Constant Ach_Char_Newline = $0d; ! ZSCII
#endif;

! 6/12 constants imported here for compatibility
#Ifndef MAX_DECIMAL_SIZE;
#Ifdef TARGET_ZCODE;                ! decimal range is -32768 to 32767
Constant MAX_DECIMAL_SIZE 5;
Constant MAX_DECIMAL_BASE 3276;
#Ifnot; ! TARGET_GLULX              ! decimal range is -2147483648 to 2147483647
Constant MAX_DECIMAL_SIZE 10;
Constant MAX_DECIMAL_BASE 214748364;
#Endif; ! TARGET_
#Endif;


Constant Ach_State_Unearned = 0;  ! includes "in progress" achs
Constant Ach_State_Earned = 1;
Constant Ach_State_Failed = 2;

Global achievements_notify = true;
Global achievements_post_routine = PostAchievementsStub;
Global achievements_propagate_depth = 0;
Global ach_persistence_enabled = true;
Global ach_filename;
Global ach_loading;

Attribute persistent;

#IfDef VORPLE_LIBRARY;
! For Vorple compatibility
Constant LEN_MYSTR = 200;
Array mystr buffer LEN_MYSTR;
Global Ach_display_tooltips = 0;        ! if equals 1, display achievements
                                        ! as a grid of icons with tooltips
#Endif;

! A vanilla achievement. By default, it has binary state (earned / unearned)
! and is never in progress.
Class Achievement
  with ach_image 0,
       award [i;
           if (self in EarnedAchievements or FailedAchievements) rtrue;
           if (self has persistent) achievements_propagate_depth++;
           move self to EarnedAchievements;
           if (achievements_notify &&
                   ((~~ach_loading) || self hasnt persistent)) {
                #IfDef VORPLE_NOTIFICATIONS;
                bp_output_stream(3, mystr, LEN_MYSTR);
                if (self has concealed) {
                    print "You've earned a hidden achievement: ";
               } else {
                   print "You've earned an achievement: ";
               }
               print (name) self, "";
               bp_output_stream(-3);
               VorpleNotification(mystr, NOTIFICATION_SUCCESS);
                #IfNot;
               print "^[";
               if (self has concealed) {
                    print "You've earned a hidden achievement:";
               } else {
                   print "You've earned an achievement:";
               }
               print (name) self, "]^";
               #Endif;
           }
           ! notify any meta achievements that depend on us
           for (i = 0: i < self.num_dependents: i++) {
               (self.&dependents-->i).complete_task(
                       self.&dependent_tasknums-->i);
           }
           ! save persistent achs if we're done propagating awards.
           ! (an ach can award a meta that awards another meta and so on.)
           if (self has persistent && --achievements_propagate_depth == 0) {
               SavePersistentAchs();
           }
       ],
       fail [i;
           if (self in EarnedAchievements or FailedAchievements) rtrue;
           if (self has persistent) achievements_propagate_depth++;
           move self to FailedAchievements;
           if (achievements_notify &&
                   ((~~ach_loading) || self hasnt persistent)) {
                #IfDef VORPLE_NOTIFICATIONS_LIBRARY;
                bp_output_stream(3, mystr, LEN_MYSTR);
                print "^";
                if (isVorpleSupported() == false) { print "["; }
                if (self has concealed) {
                    print "You have failed a hidden achievement: ";
               } else {
                   print "You have failed an achievement: ";
               }
               print (name) self, "";
               if (isVorpleSupported() == false) { print "]"; }
               print "^";
               bp_output_stream(-3);
               VorpleNotification(mystr, NOTIFICATION_ERROR);
                #IfNot;
               print "^[";
               if (self has concealed) {
                    print "You have failed a hidden achievement:";
               } else {
                   print "You have failed an achievement:";
               }
               print (name) self, "]^";
               #Endif;
           }
           for (i = 0: i < self.num_dependents: i++) {
               (self.&dependents-->i).fail();
           }
           if (self has persistent && --achievements_propagate_depth == 0) {
               SavePersistentAchs();
           }
       ],
       init [; ! called by AchievementsInit()
       ],
       progress [; ! called by AchievementsSub()
       ],
       serialize_common [;
           if (self hasnt persistent) rtrue;
           print self, " ";
           switch (parent(self)) {
               EarnedAchievements: print Ach_State_Earned;
               FailedAchievements: print Ach_State_Failed;
               default: print Ach_State_Unearned;
           }
       ],
       serialize [;
           if (self.serialize_common()) rtrue;
           new_line;
       ],
       load_common_header [buf len rest;
           if (self hasnt persistent) {
               print "*** Achievement: load: called for non-persistent
                   achievement '", (name) self, "' ***^";
               rtrue;
           }
           if (Ach_Parser.whitespace(buf, len, rest)) {
               print "*** Achievement: load: could not load achievement '",
                   (name) self, "' (whitespace) ***^";
               rtrue;
           }
           if (Ach_Parser.parse_word(buf, len, Ach_Parser.next)) {
               print "*** Achievement: load: could not load achievement '",
                   (name) self, "' (state) ***^";
               rtrue;
           }
       ],
       load_common_ending [buf len rest;
           if (Ach_Parser.newline(buf, len, rest)) {
               print "*** Achievement: load: could not load achievement '",
                   (name) self, "' (newline) ***^";
               rtrue;
           }
           if (Ach_Parser.next ~= len) {
               print "*** Achievement: load: could not load achievement '",
                   (name) self, "' (extra) ***^";
               rtrue;
           }
       ],
       load [buf len rest state;
           if (self.load_common_header(buf, len, rest)) {
               rtrue;
           }
           state = Ach_Parser.value;
           if (self.load_common_ending(buf, len, Ach_Parser.next)) {
               rtrue;
           }
           switch (state) {
               Ach_State_Earned: self.award();
               Ach_State_Failed: self.fail();
               Ach_State_Unearned: ;
               default: print "*** Achievement: load: could not load
                            achievement '", (name) self, "' (invalid state: ",
                            state, ") ***^";
                        rtrue;
           }
       ],
       ! everything below here is to support meta achievements
       num_dependents, ! number of in-use entries in our dependents array
       ! achievement objects that depend on us
       dependents 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,  ! max of 16 dependents
       ! our task number as assigned by each dependent achievement
       dependent_tasknums 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0,
       add_dependency [ach tasknum i;
           if (ach == self) {
#ifdef STRICT_MODE;
               print "*** Programming Error: Achievement: add_dependency: 
                   cannot depend on self, ignoring this dependency ***^";
#endif;
               return;
           }
           if (self.num_dependents >= self.#dependents / WORDSIZE) {
#ifdef STRICT_MODE;
               print "*** Programming Error: Achievement: add_dependency:
                   too many dependents (max is ", self.#dependents / WORDSIZE,
                   ") ***^";
#endif;
               return;
           }
           for (i = 0: i < self.num_dependents: i++) {
               if (self.&dependents-->i == ach) {
#ifdef STRICT_MODE;
                   print "*** Programming Error: Achievement: add_dependency:
                       duplicate dependency on achievement '", (name) ach,
                       "', ignoring this dependency ***^";
#endif;
                   return;
               }
           }
           self.&dependents-->(self.num_dependents) = ach;
           self.&dependent_tasknums-->(self.num_dependents++) = tasknum;
       ],
  has proper; ! for debug verb output (e.g., tree)

! An achievement that requires that an action be performed a certain number of
! times before the achievement is awarded. target_count is the total number of
! times that the action must be performed. count is the number of times that
! action has been performed. The default values (count = 0, target_count = 1)
! mimic a regular achievement.
Class CountingAchievement
  class Achievement,
  with target_count 1,
       count,
       increment [;
           if (self.count == self.target_count) return;
           if (self in UnearnedAchievements) {
               move self to InProgressAchievements;
           }
           if (++self.count == self.target_count) {
               self.award();
           }
           if (self has persistent && (self in FailedAchievements ||
                   self.count ~= self.target_count)) {
               SavePersistentAchs();
           }
       ],
       progress [;
           print " (progress: ", self.count, "/", self.target_count, ")";
       ],
       serialize [;
           if (self.serialize_common()) rtrue;
           print " ", self.count, "^";
       ],
       load [buf len rest state cnt;
           if (self.load_common_header(buf, len, rest)) {
               rtrue;
           }
           state = Ach_Parser.value;
           if (Ach_Parser.whitespace(buf, len, Ach_Parser.next)) {
               print "*** CountingAchievement: load: could not load achievement
                   '", (name) self, "' (whitespace) ***^";
               rtrue;
           }
           if (Ach_Parser.parse_word(buf, len, Ach_Parser.next)) {
               print "*** CountingAchievement: load: could not load achievement
                   '", (name) self, "' (cnt) ***^";
               rtrue;
           }
           cnt = Ach_Parser.value;
           if (self.load_common_ending(buf, len, Ach_Parser.next)) {
               rtrue;
           }
           switch (state) {
               Ach_State_Earned: ;
               Ach_State_Failed: self.fail();
               Ach_State_Unearned: ;
               default: print "*** CountingAchievement: load: could not load
                            achievement '", (name) self, "' (invalid state: ",
                            state, ") ***^";
                            rtrue;
           }
           if (self.count ~= cnt) {
               self.count = cnt - 1;
               self.increment();
           }
       ];

! An achievement that requires that all of a set of tasks be performed before
! the achievement is awarded. Distinct from CountingAchievement in that
! repetition of one of the subtasks does not advance progress towards
! completion. The subtasks are not interchangeable and each must be completed
! at least once.
Class MultiAchievement
  class Achievement,
#ifdef TARGET_ZCODE;
  with taskflags 0 0 0 0,  ! 16-bit words x4 -> 8 bytes -> 64 flags
#ifnot; ! TARGET_GLULX
  with taskflags 0 0,      ! 32-bit words x2 -> 8 bytes -> 64 flags
#endif;
       invalid_task [task;
           if (task < 0 || task >= self.num_tasks) {
#ifdef STRICT_MODE;
               print "*** Programming Error: MultiAchievement: invalid_task:
                   task ", task, " is out of the legal range [0, ",
                   self.num_tasks - 1, "] ***^";
#endif;
               rtrue;
           }
       ],
       complete_task [task;
           if (self.invalid_task(task)) return;
           if (FlagOn(task, self.&taskflags)) return;
           ! mark completion of this task
           SetFlag(task, 1, self.&taskflags);
           if (self in UnearnedAchievements) {
               move self to InProgressAchievements;
           }
           ! see if all target tasks are now completed
           for (task = 0: task < self.num_tasks: task++) {
               if (~~FlagOn(task, self.&taskflags)) break;
           }
           if (task == self.num_tasks) {
               self.award();
           }
           if (self has persistent && achievements_propagate_depth == 0 &&
                   (self in FailedAchievements || task < self.num_tasks)) {
               SavePersistentAchs();
           }
       ],
       is_task_completed [task;
           if (self.invalid_task(task)) rfalse;
           return FlagOn(task, self.&taskflags);
       ],
       num_tasks_completed [task n_complete;
           for (task = 0: task < self.num_tasks: task++) {
               if (FlagOn(task, self.&taskflags)) n_complete++;
           }
           return n_complete;
       ],
       num_tasks 1,
       init [num_taskflagbits;
           num_taskflagbits = self.#taskflags * 8;
           if (self.num_tasks < 1) {
#ifdef STRICT_MODE;
               print "*** Programming Error: MultiAchievement: init: num_tasks
                   (", self.num_tasks, ") < min (1), setting it to 1. ***^";
#endif;
               self.num_tasks = 1;
           } else if (self.num_tasks > num_taskflagbits) {
#ifdef STRICT_MODE;
               print "*** Programming Error: MultiAchievement: init: num_tasks
                   (", self.num_tasks, ") > max (", num_taskflagbits, "),
                   resetting it to ", num_taskflagbits, ". ***^";
#endif;
               self.num_tasks = num_taskflagbits;
           }
       ],
       progress [;
           print " (progress: ", self.num_tasks_completed(), "/",
               self.num_tasks, ")";
       ],
       serialize [i;
           if (self.serialize_common()) rtrue;
           print " ";
           for (i = 0: i < self.#taskflags / WORDSIZE - 1: i++) {
               print self.&taskflags-->i, " ";
           }
           print self.&taskflags-->i, "^";
       ],
       load [buf len rest state expected_words wordnum taskword
               a_finished_task i;
           if (self.load_common_header(buf, len, rest)) {
               rtrue;
           }
           state = Ach_Parser.value;
           if (Ach_Parser.whitespace(buf, len, Ach_Parser.next)) {
               print "*** MultiAchievement: load: could not load achievement
                   '", (name) self, "' (whitespace) ***^";
               rtrue;
           }
           rest = Ach_Parser.next; ! remember beginning of taskflags
           ! ensure that we have the expected number of words of taskflags
           ! before we begin to load them.
           expected_words = self.#taskflags / WORDSIZE;
           for (wordnum = 0: wordnum < expected_words: wordnum++) {
               if (Ach_Parser.parse_word(buf, len, Ach_Parser.next)) {
                   break;
               }
               if (wordnum < expected_words - 1) {
                   if (Ach_Parser.whitespace(buf, len, Ach_Parser.next)) {
                       break;
                   }
               } else if (Ach_Parser.newline(buf, len, Ach_Parser.next)) {
                   break;
               }
           }
           ! complain if we haven't reached end of the buffer. we must have
           ! seen something we didn't like.
           if (Ach_Parser.next ~= len) {
               print "*** MultiAchievement: load: could not load achievement
                   '", (name) self, "' (taskflags ill-formed) ***^";
               rtrue;
           }
           ! complain if we have reached the end of the buffer without having
           ! seen enough words of taskflags.
           if (wordnum < expected_words) {
               print "*** MultiAchievement: load: could not load achievement
                   '", (name) self, "' (taskflags incomplete: ", wordnum,
                   "/", expected_words, " available) ***^";
               rtrue;
           }
           ! we're now happy with the format of the ach data and we begin to
           ! hande its semantics.
           switch (state) {
               Ach_State_Earned: ;
               Ach_State_Failed: self.fail();
               Ach_State_Unearned: ;
               default: print "*** MultiAchievement: load: could not load
                            achievement '", (name) self, "' (invalid state: ",
                            state, ") ***^";
                        rtrue;
           }
           ! parse and load taskflags word by word.
           ! don't need to worry about format since we already checked above.
           a_finished_task = -1;
           Ach_Parser.next = rest; ! reset parsing to beginning of taskflags
           for (wordnum = 0: wordnum < expected_words: wordnum++) {
               Ach_Parser.parse_word(buf, len, Ach_Parser.next);
               taskword = Ach_Parser.value;
               if (wordnum < expected_words - 1) {
                   Ach_Parser.whitespace(buf, len, Ach_Parser.next);
               } else {
                   Ach_Parser.newline(buf, len, Ach_Parser.next);
               }
               self.&taskflags-->wordnum = taskword;
               ! locate an arbitrary task that has already been completed, if
               ! there is one. we'll use this to force a reeval of achievement
               ! completion state when we're done, without having to call
               ! complete_task() for every bit that's set.
               if (a_finished_task < 0 && taskword) {
                   for (i = wordnum * WORDSIZE * 8:
                           i < (wordnum + 1) * WORDSIZE * 8: i++) {
                       if (FlagOn(i, self.&taskflags)) {
                           a_finished_task = i;
                           break;
                       }
                   }
               }
           }
           ! update completion state if any tasks have been completed
           if (a_finished_task >= 0) {
               SetFlag(a_finished_task, 0, self.&taskflags);
               self.complete_task(a_finished_task);
           }
       ];

! Meta achievements that are completed when a set of other achievements are
! completed. These are a special case of the multi achievements defined above,
! where the tasks to be completed are the earning of other achievements. The
! bulk of the heavy lifting to support this is done in MultiAchievement and
! Achievement.
!
! Note that a meta achievement is awarded if, at any time, all of the
! achievements on which it depends are earned. It remains awarded even if this
! later ceases to be true, as in the case where a persistent meta achievement
! depending on a non-persistent achievement is awarded and the game is then
! restarted.
Class MetaAchievement
  class MultiAchievement,
  with depends_on, ! property array of dependent ach objects
  init [i num_dependencies num_taskflagbits;
      num_dependencies = self.#depends_on / WORDSIZE;
      num_taskflagbits = self.#taskflags * 8;
      if (num_dependencies > num_taskflagbits) {
#ifdef STRICT_MODE;
          print "*** Programming Error: MetaAchievement: init: num_dependencies
             (", num_dependencies, ") > max (", num_taskflagbits, "), ignoring
             some dependencies. ***^";
#endif;
          num_dependencies = num_taskflagbits;
      }
      ! iterate through the achievements on which we depend and tell each one
      ! to notify us with a unique task number when it is completed.
      self.num_tasks = 0;
      for (i = 0: i < num_dependencies: i++) {
          (self.&depends_on-->i).add_dependency(self, self.num_tasks++);
      }
  ];

Object UnearnedAchievements;

Object InProgressAchievements;

Object EarnedAchievements;

Object FailedAchievements;

! encapsulates parsing of persistent ach state
! methods return false on success and true on failure
Object Ach_Parser
  with value,   ! parsed value, valid only if successful
       next,    ! index in buffer at which to begin parsing next item,
                ! only advanced if this item was parsed successfully.
       ! consume all available whitespace
       ! returns success if at least one space found, failure otherwise
       whitespace [buf len rest;
           self.next = rest;
           while (self.next < len && buf->(self.next) == ' ') self.next++;
           self.value = ' ';
           return self.next == rest;
       ],
       ! parse a word and store its value in self.value
       ! similiar to AnyNumber library routine, but base 10 only.
       parse_word [buf len rest start i sign digit digit_count nonzero_found;
           self.next = rest;
           start = rest;
           sign = 1;
           if (start < len && buf->start == '-') {
               sign = -1;
               start++;
           }
           self.value = 0;
           for (i = start: i < len && buf->i >= '0' && buf->i <= '9': i++) {
               digit = buf->i - '0';
               ! skip leading zeros while ensuring that we don't treat a zero
               ! word as a failure.
               if (digit ~= 0) {
                   nonzero_found = true;
               } else if (~~nonzero_found) {
                   continue;
               }
               ! check for overflow
               if (++digit_count > MAX_DECIMAL_SIZE) rtrue;
               if (digit_count == MAX_DECIMAL_SIZE) {
                   if (self.value > MAX_DECIMAL_BASE) rtrue;
                   if (self.value == MAX_DECIMAL_BASE) {
                       ! 7 and 8 are final digits in max and min signed values
                       ! for both zcode (16-bits) and glulx (32-bits).
                       if (sign == 1 && digit > 7) rtrue;
                       if (sign == -1 && digit > 8) rtrue;
                   }
               }
               self.value = self.value * 10 + digit;
           }
           self.value = self.value * sign;
           self.next = i;
           if (self.next == start) {
               self.next = rest; ! start may have increased when parsing '-'
           }
           return self.next == rest;
       ],
       ! parse a specific character
       character [buf len rest char;
           self.next = rest;
           self.value = char;
           if (rest < len && buf->rest == char) {
               self.next++;
           }
           return self.next == rest;
       ],
       ! parse a newline (convenience)
       newline [buf len rest;
           return self.character(buf, len, rest, Ach_Char_Newline);
       ],
  has proper;

[ SavePersistentAchs;
  if (~~ach_persistence_enabled) return;
  if (ach_loading) return;
#ifdef TARGET_ZCODE;
  SavePersistentAchsZ();
#ifnot; ! TARGET_GLULX
  SavePersistentAchsG();
#endif;
];

#ifdef TARGET_ZCODE;
Constant Ach_ZFile_Bufsize = 128; ! XXX longer?
Array ach_zfile_buf buffer Ach_ZFile_Bufsize;

[ SavePersistentAchsZ ach len prompt result;
#ifdef DEBUG;
  print "SavePersistentAchsZ called.^";
#endif;
  ! TODO: add overflow prevention. add a "dry-run" form of serialize() that
  ! returns the number of bytes that the real serialize would print. we can
  ! compare the cumulative sum of these values with Ach_ZFile_Bufsize to
  ! determine if it's safe for the next ach to serialize into the buffer.
  @output_stream 3 ach_zfile_buf;
  ! unearned achievements don't have any state worth saving (yet)
  objectloop (ach in InProgressAchievements) {
      if (ach hasnt persistent) continue;
      ach.serialize();
  }
  objectloop (ach in EarnedAchievements) {
      if (ach hasnt persistent) continue;
      ach.serialize();
  }
  objectloop (ach in FailedAchievements) {
      if (ach hasnt persistent) continue;
      ach.serialize();
  }
  @output_stream -3;
  len = ach_zfile_buf-->0 + WORDSIZE; ! length is prepended to the ach data
  @save ach_zfile_buf len ach_filename_buf prompt -> result;
  if (~~result) {
      print "*** SavePersistentAchsZ: @@64save to '", (string) ach_filename,
          "' failed ***^";
      return;
  }
  ! XXX POTENTIAL SHOWSTOPPERS FOR Z-MACHINE PERSISTENCE
  !
  ! zcode interpreters are behaving poorly:
  ! (1) not honoring the filename that we provide.
  ! (2) prompting the user at each @save/@restore despite the prompt arg being
  !     set to 0
  !
  ! have tested: unix frotz, glulxe+glkterm, gargoyle, spatterlight, zoom
  !
  ! all of these behave reasonably for glulx, with slight differences in
  !   file suffix and location.
  !
  ! all of these behave poorly for zcode:
  ! -all but zoom prompt the player when @saving and @restoring.
  ! -gargoyle prompts w/ no default filename and appends/requires .sav suffix.
  ! -spatterlight prompts w/ no default filename, appends .dat suffix, and
  !  reports failed @save despite having saved successfully.
  ! -zoom doesn't prompt, but fails to @save file or to locate preexisting file
  !  during @restore.
];
#endif; ! TARGET_ZCODE

#ifdef TARGET_GLULX;
[ SavePersistentAchsG fileref stream prev_stream ach;
#ifdef DEBUG;
  print "SavePersistentAchsG called.^";
#endif;
  fileref = glk_fileref_create_by_name(fileusage_Data | fileusage_BinaryMode,
      ChangeAnyToCString(ach_filename), 0);
  if (~~fileref) {
      print "*** SavePersistentAchsG: could not create fileref for '",
          (string) ach_filename, "' ***^";
      return;
  }
  stream = glk_stream_open_file(fileref, filemode_Write, 0);
  glk_fileref_destroy(fileref);
  if (~~stream) {
      print "*** SavePersistentAchsG: could not open file stream for '",
          (string) ach_filename, "' ***^";
      return;
  }
  prev_stream = glk_stream_get_current();
  glk_stream_set_current(stream);
  ! unearned achievements don't have any state worth saving (yet)
  objectloop (ach in InProgressAchievements) {
      if (ach hasnt persistent) continue;
      ach.serialize();
  }
  objectloop (ach in EarnedAchievements) {
      if (ach hasnt persistent) continue;
      ach.serialize();
  }
  objectloop (ach in FailedAchievements) {
      if (ach hasnt persistent) continue;
      ach.serialize();
  }
  glk_stream_set_current(prev_stream);
  glk_stream_close(stream, 0);
];
#endif; ! TARGET_GLULX

! hook into successful meta actions
Object Ach_MetaActionHook LibraryExtensions
  with ext_messages [;
           Restore:
               if (lm_n == 2) {
                   LoadPersistentAchs();
               }
           Miscellany:
               if (lm_n == 13) {  ! undo
                   LoadPersistentAchs();
               }
       ],
  has proper;

[ LoadPersistentAchs;
  if (~~ach_persistence_enabled) return;
  ! disable player notifications and saving state updates for persistent achs
  ! while we're in the process of loading them.
  ach_loading = true;
#ifdef TARGET_ZCODE;
  LoadPersistentAchsZ();
#ifnot; ! TARGET_GLULX
  LoadPersistentAchsG();
#endif;
  ach_loading = false;
];

Constant Ach_Load_Bufsize = 32; ! XXX longer?
Array ach_load_buf -> Ach_Load_Bufsize;

#ifdef TARGET_ZCODE;
[ LoadPersistentAchsZ len prompt result rest i newline_found;
#ifdef DEBUG;
  print "LoadPersistentAchsZ called.^";
#endif;
  ! read achievement data from file into zfile buffer
  len = Ach_ZFile_Bufsize + WORDSIZE;
  @restore ach_zfile_buf len ach_filename_buf prompt -> result;
  if (~~result) {
      return;
  }
  ! validate data length
  if (result < WORDSIZE) {
      print "*** LoadPersistentAchsZ: read too few bytes for length ***^";
      return;
  }
  if (result - WORDSIZE ~= ach_zfile_buf-->0) {
      print "*** LoadPersistentAchsZ: stored length (", ach_zfile_buf-->0,
          ") is inconsistent with bytes read (", result, ") ***^";
      return;
  }
  ! parse data line by line into load buffer
  rest = WORDSIZE;
  while (rest < result) {
      newline_found = false;
      for (i = 0: rest < result && (~~newline_found): rest++) {
          if (i < Ach_Load_Bufsize) {
              ach_load_buf->(i++) = ach_zfile_buf->rest;
          }
          if (ach_zfile_buf->rest == Ach_Char_Newline) {
              newline_found = true;
          }
      }
      if (~~newline_found) {
          print "*** LoadPersistentAchsZ: data ended prematurely (no newline
              found) ***^";
          return;
      }
      ! load buffer now contains a full line of achievement data
      ! parse and dispatch it
      ParseAchData(ach_load_buf, i);
  }
];
#endif; ! TARGET_ZCODE

#ifdef TARGET_GLULX;
[ LoadPersistentAchsG fileref stream len;
#ifdef DEBUG;
  print "LoadPersistentAchsG called.^";
#endif;
  fileref = glk_fileref_create_by_name(fileusage_Data | fileusage_BinaryMode,
      ChangeAnyToCString(ach_filename), 0);
  if (~~fileref) {
      print "*** LoadPersistentAchsG: could not create fileref for '",
          (string) ach_filename, "' ***^";
      return;
  }
  if (~~glk_fileref_does_file_exist(fileref)) {
      glk_fileref_destroy(fileref);
      return;
  }
  stream = glk_stream_open_file(fileref, filemode_Read, 0);
  glk_fileref_destroy(fileref);
  if (~~stream) {
      print "*** LoadPersistentAchsG: could not open file stream for '",
          (string) ach_filename, "' ***^";
      return;
  }
  len = glk_get_line_stream(stream, ach_load_buf, Ach_Load_Bufsize);
  while (len > 0) {
      ParseAchData(ach_load_buf, len);
      len = glk_get_line_stream(stream, ach_load_buf, Ach_Load_Bufsize);
  }
  glk_stream_close(stream, 0);
];
#endif; ! TARGET_GLULX

[ ParseAchData buf len rest ach;
  if (Ach_Parser.parse_word(buf, len, rest)) {
      print "*** ParseAchData: could not parse object id ***^";
      return;
  }
  ach = Ach_Parser.value;
  ! dispatch to 'ach' and allow it to interpret the rest of the data and update
  ! its state accordingly.
  if (ach ofclass Achievement) {
#ifdef DEBUG;
      print "ParseAchData: loading '", (name) ach, "'^";
#endif;
      ach.load(buf, len, Ach_Parser.next);
  } else {
      print "*** ParseAchData: object ", ach, " is not an Achievement ***^";
  }
];

[ PostAchievementsStub;
];

#ifdef TARGET_ZCODE;
Constant Ach_Filename_Bufsize = 80; ! based on max filename size in frotz
Array ach_filename_buf buffer Ach_Filename_Bufsize;

[ AchievementsInit filename post_ach_cb ach i;
#ifnot; ! TARGET_GLULX
[ AchievementsInit filename post_ach_cb ach;
#endif;
  if (filename && metaclass(filename) == String) {
      ach_filename = filename;
#ifdef DEBUG;
      print "ach_filename = ", (string) ach_filename, "^";
#endif;
  } else {
      ! TODO: generate default filename based on Story instead of giving up.
      ach_persistence_enabled = false;
#ifdef STRICT_MODE;
      print "*** Warning: AchievementsInit: no filename provided, disabling
          persistent achievements ***^";
#endif;
  }

! copy ach_filename into ach_filename_buf for use by zcode @save and @restore.
! XXX any way to guard against buffer overflow?
! XXX should we punt on this and require caller to pass a string array?
#ifdef TARGET_ZCODE;
  ach_filename.print_to_array(ach_filename_buf);
  ! print_to_array prints to a buffer array where first WORDSIZE bytes contain
  ! the string length. @save and @restore expect the filename to be in a string
  ! array where only the first byte contains the string length. So, we must
  ! convert from one to the other.
  !
  ! truncate string if too long for length to fit in a byte (> 255 bytes).
  if (ach_filename_buf-->0 > 255) {
      ach_filename_buf-->0 = 255;
  }
  ! place length in buf->0 instead of buf-->0, then move everything one byte
  ! to the left.
  ach_filename_buf->0 = ach_filename_buf-->0;
  for (i = WORDSIZE: i <= ach_filename_buf->0 + WORDSIZE - 1: i++) {
      ach_filename_buf->(i - 1) = ach_filename_buf->i;
  }
#endif;

  if (post_ach_cb) {
      achievements_post_routine = post_ach_cb;
  }
  objectloop (ach ofclass Achievement) {
      if (~~parent(ach)) {
          move ach to UnearnedAchievements;
      }
      ach.init();
  }
  LoadPersistentAchs();
];







!====================================
! Display the achievement list
!
! It can be displayed as a list with icons and description, or as a list
! of icons with description in a tooltip (for this, set Ach_display_tooltips
! to 1).

#Ifdef VORPLE_LIBRARY;
Constant LEN_ACH_DESC 200;
Array ach_desc buffer LEN_ACH_DESC;
Constant ACH_PER_LINE 7;
Global ach_on_this_line = 0;
#Endif;

[ DisplayAchievement ach      id ;
    Ach_display_tooltips = 1;
    ! test if it's of class achievement ? or not needed ?
    
    ! ignore concealed unlocked/unfailed achievements
    if (ach has concealed &&
        (ach in InProgressAchievements || ach in UnearnedAchievements) ) {
        return;
    }
    
#Ifdef VORPLE_LIBRARY;
    ! assume the tr has already been opened
    ! the description of the achievement
    
    ! the image
    if (Ach_display_tooltips == 1 && ach_on_this_line >= ACH_PER_LINE) {
        VorpleCloseHTMLTag(); ! close the tr
        VorpleOpenHTMLTag("tr"); ! open a new one
        ach_on_this_line=0;
    }
    ach_on_this_line++;
    id = UniqueIdentifier();
    if (ach.ach_image ~= 0 && isVorpleSupported() ) {
                        VorpleOpenHTMLTag("td");
                        VorpleImage(ach.ach_image, "", "", id);
                        VorpleCloseHTMLTag();
    }
    
    ! the text
    if (Ach_display_tooltips == 0 || isVorpleSupported()==0) {
        VorpleOpenHTMLTag("td");
    } else {
        bp_output_stream(3, ach_desc, LEN_ACH_DESC);
    }
#Endif;

    ! print achievement
    print "  ", (name) ach, " (", (string) ach.description, ")";

    ! print progress if relevant
    if (ach in InProgressAchievements) { ach.progress(); }
#ifdef debug;
    if (ach in FailedAchievements) { ach.progress(); }
#endif;

    ! print "(hidden)"
    if (ach has concealed &&
        (ach in EarnedAchievements || ach in FailedAchievements) ) {
        print " (hidden)";
    }

    ! print "(persistent)"
    ! if (ach has persistent) print " (persistent)";

#Ifdef VORPLE_LIBRARY;
    if (Ach_display_tooltips == 0 || isVorpleSupported()==0 ) {
        VorpleCloseHTMLTag();  ! end of the td
        ! this way of creating a new line means there's an extra
        ! blank one at the end, which could be fixed, but it makes
        ! the code much more readable to do it this way
        VorpleCloseHTMLTag(); ! end of the tr
        VorpleOpenHTMLTag("tr");
    } else {
        bp_output_stream(-3);
        VorpleTooltipElementMouse(ach_desc, id);
    }
    if (isVorpleSupported()) {return true;}
#Endif;
    new_line;
    return true;
];

[ AchievementsSub ach earned_printed in_progress_printed failed_printed;
! TODO: do we want a nice bullet point list in vorple without multimedia ?
!    (displayunorderedlist in screen-effects)
! TODO:display unearned & in progress achievements as a black-and-white picture of the icon, using the css
        ! unearned_ach {
        !   -webkit-filter: grayscale(1);
        !   filter: grayscale(1);
        ! }

  if (~~child(EarnedAchievements)) {
      print "You haven't earned any achievements.^";
  } else {
      print "You have earned the following achievements:^";
        #Ifdef VORPLE_LIBRARY;
        VorpleOpenHTMLTag("table");
        VorpleOpenHTMLTag("tr");
        #Endif;
      objectloop (ach in EarnedAchievements) {
          DisplayAchievement(ach);
          earned_printed = true;
      }
        #Ifdef VORPLE_LIBRARY;
        VorpleCloseHTMLTag(); ! close tr
        VorpleCloseHTMLTag(); ! close table
        ach_on_this_line = 0; ! reset the counter
        #Endif;
  }
  if (~~child(InProgressAchievements)) {
      print "^You have no achievements in-progress.^";
  } else {
      print "^You have the following achievements in-progress:^";
        #Ifdef VORPLE_LIBRARY;
        VorpleOpenHTMLTag("table");
        VorpleOpenHTMLTag("tr");
        #Endif;
      objectloop (ach in InProgressAchievements) {
          DisplayAchievement(ach);
          in_progress_printed = true;
      }
        #Ifdef VORPLE_LIBRARY;
        VorpleCloseHTMLTag(); ! close tr
        VorpleCloseHTMLTag(); ! close table
        ach_on_this_line = 0; ! reset the counter
        #Endif;
  }
  if (~~child(FailedAchievements)) {
      print "^You have no failed achievements.^";
  } else {
      print "^You have the following failed achievements:^";
        #Ifdef VORPLE_LIBRARY;
        VorpleOpenHTMLTag("table");
        VorpleOpenHTMLTag("tr");
        #Endif;
      objectloop (ach in FailedAchievements) {
          DisplayAchievement(ach);
          failed_printed = true;
      }
        #Ifdef VORPLE_LIBRARY;
        VorpleCloseHTMLTag(); ! close tr
        VorpleCloseHTMLTag(); ! close table
        ach_on_this_line = 0; ! reset the counter
        #Endif;
  }
  if (~~child(UnearnedAchievements)) {
      print "^There are no ";
      if (earned_printed || in_progress_printed || failed_printed) {
          print "other ";
      }
      print "achievements available at this time.^";
  } else {
      print "^The following achievements are available:^";
        #Ifdef VORPLE_LIBRARY;
        VorpleOpenHTMLTag("table");
        VorpleOpenHTMLTag("tr");
        #Endif;
      objectloop (ach in UnearnedAchievements) {
          DisplayAchievement(ach);
      }
        #Ifdef VORPLE_LIBRARY;
        VorpleCloseHTMLTag(); ! close tr
        VorpleCloseHTMLTag(); ! close table
        ach_on_this_line = 0; ! reset the counter
        #Endif;
  }  

  if (metaclass(achievements_post_routine) == Routine) {
      achievements_post_routine();
  }
];

[ AchievementsOnSub;
  achievements_notify = true;
  "Achievement notification on.";
];

[ AchievementsOffSub;
  achievements_notify = false;
  "Achievement notification off.";
];

Verb meta 'achievements' 'ach'
    *       -> Achievements
    * 'on'  -> AchievementsOn
    * 'off' -> AchievementsOff;
